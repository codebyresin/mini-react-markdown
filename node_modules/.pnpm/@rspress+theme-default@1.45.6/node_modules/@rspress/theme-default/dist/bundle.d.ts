import { ComponentProps } from 'react';
import { ComponentPropsWithRef } from 'react';
import { Dispatch } from 'react';
import { FC } from 'react';
import { ForwardRefExoticComponent } from 'react';
import type { FrontMatterMeta } from '@rspress/shared';
import { Header } from '@rspress/shared';
import { JSX as JSX_2 } from 'react/jsx-runtime';
import { LayoutProps } from './layout/Layout';
import type { LocalSearchOptions } from '@rspress/shared';
import { NormalizedLocales } from '@rspress/shared';
import { NormalizedSidebarGroup } from '@rspress/shared';
import { default as React_2 } from 'react';
import { ReactElement } from 'react';
import { ReactNode } from 'react';
import { RefAttributes } from 'react';
import type { RemoteSearchOptions } from '@rspress/shared';
import { SetStateAction } from 'react';
import { SidebarDivider } from '@rspress/shared';
import { SidebarItem } from '@rspress/shared';
import type { SocialLink } from '@rspress/shared';

export declare type AfterSearch = (query: string, matchedResult: MatchResult) => void | Promise<void>;

export declare function Aside({ headers, outlineTitle, }: {
    headers: Header[];
    outlineTitle: string;
}): JSX_2.Element;

/**
 * A component that renders a styled badge with custom content.
 *
 * The Badge component displays a small, inline element with customizable content and appearance.
 * It's useful for highlighting status, categories, or other short pieces of information.
 *
 * @param {BadgeProps} props - The properties for the Badge component.
 * @returns {JSX.Element} A span element representing the badge.
 *
 * @example
 * Using children:
 * <Badge type="info">New</Badge>
 * <Badge type="warning" outline>Experimental</Badge>
 * <Badge type="danger">Deprecated</Badge>
 * <Badge type="tip" outline><strong>Pro Tip:</strong> Use custom elements</Badge>
 *
 * Using text prop:
 * <Badge text="New" type="info" />
 * <Badge text="Experimental" type="warning" outline />
 * <Badge text="Deprecated" type="danger" />
 */
export declare function Badge({ children, type, text, outline, }: BadgeProps): JSX_2.Element;

declare interface BadgeProps {
    /**
     * The content to display inside the badge. Can be a string or React nodes.
     */
    children?: React.ReactNode;
    /**
     * The type of badge, which determines its color and style.
     * @default 'tip'
     */
    type?: 'tip' | 'info' | 'warning' | 'danger';
    /**
     * The text content to display inside the badge (for backwards compatibility).
     */
    text?: string;
    /**
     * Whether to display the badge with an outline style.
     * @default false
     */
    outline?: boolean;
}

export declare type BeforeSearch = (query: string) => string | Promise<string> | void;

export declare function Button(props: ButtonProps): React_2.CElement<{
    className: string;
    href: string;
}, React_2.Component<{
    className: string;
    href: string;
}, any, any>>;

declare interface ButtonProps {
    type?: string;
    size?: 'medium' | 'big';
    theme?: 'brand' | 'alt';
    text: string | React_2.ReactNode;
    href?: string;
    external?: boolean;
    className?: string;
}

export declare function Card({ content, title, icon, style }: CardProps): JSX_2.Element;

declare interface CardProps {
    /**
     * The title of the card.
     */
    title: React.ReactNode;
    /**
     * The content to display inside the card.
     */
    content?: React.ReactNode;
    /**
     * The icon of the card.
     */
    icon?: React.ReactNode;
    /**
     * The style of the card.
     */
    style?: React.CSSProperties;
}

declare function Code(props: CodeProps): JSX_2.Element;

export declare interface CodeProps {
    children: string;
    className?: string;
    codeHighlighter?: 'prism' | 'shiki';
    meta?: string;
}

declare interface CommonMatchResult {
    title: string;
    header: string;
    link: string;
    query: string;
    highlightInfoList: HighlightInfo[];
}

declare interface ContentMatch extends CommonMatchResult {
    type: 'content';
    statement: string;
}

export declare type CustomMatchResult = UserMatchResultItem & {
    renderType: RenderType.Custom;
};

declare const _default: {
    Layout: FC<LayoutProps>;
    NotFoundLayout: typeof NotFoundLayout;
    HomeLayout: typeof HomeLayout;
    useBindingAsideScroll: typeof useBindingAsideScroll;
    useSetup: typeof useSetup;
};
export default _default;

export declare type DefaultMatchResult = {
    group: string;
    renderType: RenderType;
    result: DefaultMatchResultItem[];
};

export declare type DefaultMatchResultItem = TitleMatch | HeaderMatch | ContentMatch;

export declare function DocFooter(): JSX_2.Element;

export declare function DocLayout(props: DocLayoutProps): JSX_2.Element;

declare interface DocLayoutProps {
    beforeSidebar?: React.ReactNode;
    afterSidebar?: React.ReactNode;
    beforeDocFooter?: React.ReactNode;
    afterDocFooter?: React.ReactNode;
    beforeDoc?: React.ReactNode;
    afterDoc?: React.ReactNode;
    beforeDocContent?: React.ReactNode;
    afterDocContent?: React.ReactNode;
    beforeOutline?: React.ReactNode;
    afterOutline?: React.ReactNode;
    uiSwitch?: UISwitchResult;
    navTitle?: React.ReactNode;
    components?: Record<string, React.FC>;
}

export declare function EditLink(): JSX_2.Element | null;

export declare function getCustomMDXComponent(): {
    h1: (props: React.ComponentProps<"h1">) => JSX_2.Element;
    h2: (props: React.ComponentProps<"h2">) => JSX_2.Element;
    h3: (props: React.ComponentProps<"h3">) => JSX_2.Element;
    h4: (props: React.ComponentProps<"h4">) => JSX_2.Element;
    h5: (props: React.ComponentProps<"h5">) => JSX_2.Element;
    h6: (props: React.ComponentProps<"h6">) => JSX_2.Element;
    ul: (props: ComponentProps<"ul">) => JSX_2.Element;
    ol: (props: ComponentProps<"ol">) => JSX_2.Element;
    li: (props: ComponentProps<"li">) => JSX_2.Element;
    table: (props: ComponentProps<"table">) => JSX_2.Element;
    td: (props: ComponentProps<"td">) => JSX_2.Element;
    th: (props: ComponentProps<"th">) => JSX_2.Element;
    tr: (props: ComponentProps<"tr">) => JSX_2.Element;
    hr: (props: ComponentProps<"hr">) => JSX_2.Element;
    p: (props: ComponentProps<"p">) => JSX_2.Element;
    blockquote: (props: ComponentProps<"blockquote">) => JSX_2.Element;
    strong: (props: ComponentProps<"strong">) => JSX_2.Element;
    a: (props: ComponentProps<"a">) => JSX_2.Element;
    code: typeof Code;
    pre: typeof Pre;
    img: (props: ComponentProps<"img">) => JSX_2.Element;
};

declare interface Group {
    name: string;
    items: GroupItem[];
}

declare interface GroupItem {
    text: string;
    link: string;
    headers?: Header[];
}

declare interface HeaderMatch extends CommonMatchResult {
    type: 'header';
}

export declare interface HighlightInfo {
    start: number;
    length: number;
}

export declare function HomeFeature({ frontmatter, routePath, }: {
    frontmatter: FrontMatterMeta;
    routePath: string;
}): JSX_2.Element;

export declare function HomeFooter(): JSX_2.Element | null;

export declare function HomeHero({ frontmatter, routePath, }: {
    frontmatter: FrontMatterMeta;
    routePath: string;
}): JSX_2.Element;

export declare function HomeLayout(props: HomeLayoutProps): JSX_2.Element;

declare interface HomeLayoutProps {
    beforeHero?: React.ReactNode;
    afterHero?: React.ReactNode;
    beforeFeatures?: React.ReactNode;
    afterFeatures?: React.ReactNode;
}

export declare function LastUpdated(): JSX_2.Element;

export declare const Layout: React_2.FC<LayoutProps_2>;

declare type LayoutProps_2 = {
    top?: React_2.ReactNode;
    bottom?: React_2.ReactNode;
    /**
     * Control whether or not to display the navbar, sidebar, outline and footer
     */
    uiSwitch?: Partial<UISwitchResult>;
} & Omit<DocLayoutProps, 'uiSwitch'> & HomeLayoutProps & NavProps;

/**
 * What's the difference between <Link> and <a>?
 * Link can tell whether it's in current site or external site.
 * 1. If external, open a new page and navigate to it.
 * 2. If inCurrentPage, scroll to anchor.
 * 3. If inCurrentSite, it will navigate and scroll to anchor, preload the asyncChunk onHover the link
 * 4. Link is styled.
 */
export declare function Link(props: LinkProps): JSX_2.Element;

export declare function LinkCard(props: LinkCardProps): JSX_2.Element;

declare interface LinkCardProps {
    /**
     * The URL of the link.
     */
    href: string;
    /**
     * The title of the link.
     */
    title: string;
    /**
     * The description of the link.
     */
    description?: React.ReactNode;
    /**
     * The style of the link card.
     */
    style?: React.CSSProperties;
}

declare interface LinkProps extends ComponentProps<'a'> {
    href?: string;
    children?: React_2.ReactNode;
    className?: string;
    onNavigate?: () => void;
    keepCurrentParams?: boolean;
}

export declare type MatchResult = (DefaultMatchResult | CustomMatchResult)[];

export declare function Nav(props: NavProps): JSX_2.Element;

declare interface NavProps {
    beforeNav?: React.ReactNode;
    beforeNavTitle?: React.ReactNode;
    navTitle?: React.ReactNode;
    afterNavTitle?: React.ReactNode;
    afterNavMenu?: React.ReactNode;
}

export declare function NotFoundLayout(): JSX_2.Element;

export declare type OnSearch = (query: string, matchedResult: DefaultMatchResult[]) => {
    group: string;
    result: unknown;
    renderType?: RenderType;
}[] | Promise<{
    group: string;
    result: unknown;
    renderType?: RenderType;
}[]> | void;

export declare function Overview(props: {
    content?: React.ReactNode;
    groups?: Group[];
    defaultGroupTitle?: string;
    overviewHeaders?: number[];
}): JSX_2.Element;

declare interface PackageManagerTabProps {
    command: string | {
        npm?: string;
        yarn?: string;
        pnpm?: string;
        bun?: string;
    };
    additionalTabs?: {
        tool: string;
        icon?: ReactNode;
    }[];
}

export declare function PackageManagerTabs({ command, additionalTabs, }: PackageManagerTabProps): JSX_2.Element;

export declare type PageSearcherConfig = {
    currentLang: string;
    currentVersion: string;
};

export declare function parseInlineMarkdownText(mdx: string): string;

declare function Pre({ children, }: {
    children: React.ReactElement[] | React.ReactElement;
}): JSX_2.Element;

export declare function PrevNextPage(props: PrevNextPageProps): JSX_2.Element;

declare interface PrevNextPageProps {
    type: 'prev' | 'next';
    text: string;
    href: string;
}

declare interface Props {
    isSidebarOpen?: boolean;
    beforeSidebar?: React.ReactNode;
    afterSidebar?: React.ReactNode;
    uiSwitch?: UISwitchResult;
    navTitle?: React.ReactNode;
}

export declare function renderHtmlOrText(str?: string | number | null): ReactNode;

/**
 * In this method, we will render the markdown text to inline html and support basic markdown syntax, including the following:
 * - bold
 * - emphasis
 * - delete
 * - inline code
 * @param text The markdown text to render.
 */
export declare function renderInlineMarkdown(text: string): ReactNode;

export declare type RenderSearchFunction<T = unknown> = (result: T) => JSX.Element;

export declare const enum RenderType {
    Default = "default",
    Custom = "custom"
}

export declare function scrollToTarget(target: HTMLElement, isSmooth: boolean, scrollPaddingTop: number): void;

export declare function ScrollToTop(): JSX_2.Element;

export declare function Search(): JSX_2.Element;

export declare type SearchOptions = (LocalSearchOptions | RemoteSearchOptions) & PageSearcherConfig;

export declare function SearchPanel({ focused, setFocused }: SearchPanelProps): JSX_2.Element | null;

declare interface SearchPanelProps {
    focused: boolean;
    setFocused: (focused: boolean) => void;
}

export declare function Sidebar(props: Props): JSX_2.Element;

export declare type SidebarData = (SidebarDivider | SidebarItem | NormalizedSidebarGroup)[];

export declare function SidebarList({ sidebarData, setSidebarData, }: {
    sidebarData: SidebarData;
    setSidebarData: React.Dispatch<React.SetStateAction<SidebarData>>;
}): JSX_2.Element;

export declare const SocialLinks: ({ socialLinks }: {
    socialLinks: SocialLink[];
}) => JSX_2.Element;

export declare function SourceCode(props: SourceCodeProps): JSX_2.Element;

declare interface SourceCodeProps {
    href: string;
    platform?: 'github' | 'gitlab';
}

export declare function Steps({ children }: {
    children: ReactNode;
}): JSX_2.Element;

export declare function SwitchAppearance({ onClick }: {
    onClick?: () => void;
}): JSX_2.Element;

export declare function Tab({ children, ...props }: ComponentPropsWithRef<'div'> & Pick<TabItem, 'label' | 'value'>): ReactElement;

declare type TabItem = {
    value?: string;
    label?: string | ReactNode;
    disabled?: boolean;
};

export declare const Tabs: ForwardRefExoticComponent<TabsProps & RefAttributes<HTMLDivElement>>;

declare interface TabsProps {
    values?: ReactNode[] | ReadonlyArray<ReactNode> | TabItem[];
    defaultValue?: string;
    onChange?: (index: number) => void;
    children: ReactNode;
    groupId?: string;
    tabContainerClassName?: string;
    tabPosition?: 'left' | 'center';
}

export declare const Tag: ({ tag }: {
    tag?: string;
}) => JSX_2.Element | null;

declare type ThemeConfigValue = ThemeValue | 'auto';

declare type ThemeValue = 'light' | 'dark';

declare interface TitleMatch extends CommonMatchResult {
    type: 'title';
}

export declare function Toc({ onItemClick, }: {
    onItemClick?: (header: Header) => void;
}): false | JSX_2.Element;

declare interface UISwitchResult {
    showNavbar: boolean;
    showSidebar: boolean;
    showSidebarMenu: boolean;
    showAside: boolean;
    showDocFooter: boolean;
    navbarHeight: number;
    sidebarMenuHeight: number;
    scrollPaddingTop: number;
}

export declare function useBindingAsideScroll(headers: Header[]): void;

export declare function useEditLink(): {
    text: string;
    link: string;
} | null;

export declare function useEnableNav(): readonly [boolean, Dispatch<SetStateAction<boolean>>];

export declare function useFullTextSearch(): {
    initialized: boolean;
    search: (keyword: string, limit?: number) => Promise<MatchResult>;
};

export declare function useHiddenNav(): boolean;

export declare function useLocaleSiteData(): NormalizedLocales;

export declare function usePrevNextPage(): {
    prevPage: SidebarItem;
    nextPage: SidebarItem;
};

/**
 * Redirect to current locale for first visit
 */
export declare function useRedirect4FirstVisit(): void;

export declare type UserMatchResultItem<T = unknown> = {
    group: string;
    result: T;
};

export declare function useSetup(): void;

export declare function useSidebarData(): SidebarData;

/**
 * State provider for theme context.
 */
export declare const useThemeState: () => readonly [ThemeValue, (value: ThemeValue, storeValue?: ThemeConfigValue) => void];

export { }
