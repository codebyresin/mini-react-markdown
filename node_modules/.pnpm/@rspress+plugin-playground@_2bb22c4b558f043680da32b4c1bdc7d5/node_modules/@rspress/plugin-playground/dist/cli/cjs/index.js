"use strict";
var __webpack_modules__ = {
    "@mdx-js/mdx": function(module) {
        module.exports = import("@mdx-js/mdx").then(function(module) {
            return module;
        });
    },
    "remark-gfm": function(module) {
        module.exports = import("remark-gfm").then(function(module) {
            return module;
        });
    },
    "../../node_modules/.pnpm/unist-util-visit@4.1.2/node_modules/unist-util-visit/lib/index.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            Vn: ()=>lib_visit
        });
        const convert = function(test) {
            if (null == test) return ok;
            if ('string' == typeof test) return typeFactory(test);
            if ('object' == typeof test) return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
            if ('function' == typeof test) return castFactory(test);
            throw new Error('Expected function, string, or object as test');
        };
        function anyFactory(tests) {
            const checks = [];
            let index = -1;
            while(++index < tests.length)checks[index] = convert(tests[index]);
            return castFactory(any);
            function any(...parameters) {
                let index = -1;
                while(++index < checks.length)if (checks[index].call(this, ...parameters)) return true;
                return false;
            }
        }
        function propsFactory(check) {
            return castFactory(all);
            function all(node) {
                let key;
                for(key in check)if (node[key] !== check[key]) return false;
                return true;
            }
        }
        function typeFactory(check) {
            return castFactory(type);
            function type(node) {
                return node && node.type === check;
            }
        }
        function castFactory(check) {
            return assertion;
            function assertion(node, ...parameters) {
                return Boolean(node && 'object' == typeof node && 'type' in node && Boolean(check.call(this, node, ...parameters)));
            }
        }
        function ok() {
            return true;
        }
        function color(d) {
            return '\u001B[33m' + d + '\u001B[39m';
        }
        const CONTINUE = true;
        const EXIT = false;
        const SKIP = 'skip';
        const visitParents = function(tree, test, visitor, reverse) {
            if ('function' == typeof test && 'function' != typeof visitor) {
                reverse = visitor;
                visitor = test;
                test = null;
            }
            const is = convert(test);
            const step = reverse ? -1 : 1;
            factory(tree, void 0, [])();
            function factory(node, index, parents) {
                const value = node && 'object' == typeof node ? node : {};
                if ('string' == typeof value.type) {
                    const name = 'string' == typeof value.tagName ? value.tagName : 'string' == typeof value.name ? value.name : void 0;
                    Object.defineProperty(visit, 'name', {
                        value: 'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'
                    });
                }
                return visit;
                function visit() {
                    let result = [];
                    let subresult;
                    let offset;
                    let grandparents;
                    if (!test || is(node, index, parents[parents.length - 1] || null)) {
                        result = toResult(visitor(node, parents));
                        if (result[0] === EXIT) return result;
                    }
                    if (node.children && result[0] !== SKIP) {
                        offset = (reverse ? node.children.length : -1) + step;
                        grandparents = parents.concat(node);
                        while(offset > -1 && offset < node.children.length){
                            subresult = factory(node.children[offset], offset, grandparents)();
                            if (subresult[0] === EXIT) return subresult;
                            offset = 'number' == typeof subresult[1] ? subresult[1] : offset + step;
                        }
                    }
                    return result;
                }
            }
        };
        function toResult(value) {
            if (Array.isArray(value)) return value;
            if ('number' == typeof value) return [
                CONTINUE,
                value
            ];
            return [
                value
            ];
        }
        const lib_visit = function(tree, test, visitor, reverse) {
            if ('function' == typeof test && 'function' != typeof visitor) {
                reverse = visitor;
                visitor = test;
                test = null;
            }
            visitParents(tree, test, overload, reverse);
            function overload(node, parents) {
                const parent = parents[parents.length - 1];
                return visitor(node, parent ? parent.children.indexOf(node) : null, parent);
            }
        };
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}
__webpack_require__.m = __webpack_modules__;
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.f = {};
    __webpack_require__.e = (chunkId)=>Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key)=>{
            __webpack_require__.f[key](chunkId, promises);
            return promises;
        }, []));
})();
(()=>{
    __webpack_require__.u = (chunkId)=>"" + chunkId + ".js";
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
(()=>{
    var installedChunks = {
        980: 1
    };
    var installChunk = (chunk)=>{
        var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
        for(var moduleId in moreModules)if (__webpack_require__.o(moreModules, moduleId)) __webpack_require__.m[moduleId] = moreModules[moduleId];
        if (runtime) runtime(__webpack_require__);
        for(var i = 0; i < chunkIds.length; i++)installedChunks[chunkIds[i]] = 1;
    };
    __webpack_require__.f.require = (chunkId, promises)=>{
        if (!installedChunks[chunkId]) installChunk(require("./" + __webpack_require__.u(chunkId)));
    };
})();
var __webpack_exports__ = {};
(()=>{
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
        pluginPlayground: ()=>pluginPlayground,
        routeMeta: ()=>cli_routeMeta
    });
    const external_node_fs_namespaceObject = require("node:fs");
    var external_node_fs_default = /*#__PURE__*/ __webpack_require__.n(external_node_fs_namespaceObject);
    const external_node_path_namespaceObject = require("node:path");
    var external_node_path_default = /*#__PURE__*/ __webpack_require__.n(external_node_path_namespaceObject);
    const node_utils_namespaceObject = require("@rspress/shared/node-utils");
    const external_rspack_plugin_virtual_module_namespaceObject = require("rspack-plugin-virtual-module");
    const DEFAULT_BABEL_URL = 'https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.20/babel.min.js';
    const DEFAULT_MONACO_URL = 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.43.0/min/vs';
    const staticPath = external_node_path_default().join(__dirname, '../../../static');
    var lib = __webpack_require__("../../node_modules/.pnpm/unist-util-visit@4.1.2/node_modules/unist-util-visit/lib/index.js");
    const napi_namespaceObject = require("@oxidation-compiler/napi");
    var napi_default = /*#__PURE__*/ __webpack_require__.n(napi_namespaceObject);
    const parseImports = (code, sourceExt)=>{
        const parsed = napi_default().parseSync(code, {
            sourceType: 'module',
            sourceFilename: `index.${sourceExt}`
        });
        const ast = JSON.parse(parsed.program);
        const result = [];
        ast.body.forEach((statement)=>{
            if ('ImportDeclaration' === statement.type) result.push(statement.source.value);
        });
        return result;
    };
    const getNodeMeta = (node, metaName)=>{
        if (!node.meta) return;
        const meta = node.meta.split(' ');
        const item = meta.find((x)=>x.startsWith(metaName));
        if (null == item ? void 0 : item.startsWith(`${metaName}=`)) return item.slice(metaName.length + 1);
        return item;
    };
    function createPlaygroundNode(currentNode, attrs) {
        Object.assign(currentNode, {
            type: 'mdxJsxFlowElement',
            name: 'Playground',
            attributes: attrs.map((it)=>({
                    type: 'mdxJsxAttribute',
                    name: it[0],
                    value: it[1]
                }))
        });
    }
    const remarkPlugin = ({ getRouteMeta, editorPosition, defaultRenderMode })=>{
        const routeMeta = getRouteMeta();
        return (tree, vfile)=>{
            const route = routeMeta.find((meta)=>(0, external_node_path_namespaceObject.resolve)(meta.absolutePath) === (0, external_node_path_namespaceObject.resolve)(vfile.path || vfile.history[0]));
            if (!route) return;
            (0, lib.Vn)(tree, 'mdxJsxFlowElement', (node)=>{
                if ('code' === node.name) {
                    const src = (0, node_utils_namespaceObject.getNodeAttribute)(node, 'src');
                    if ('string' != typeof src) return;
                    const demoPath = (0, external_node_path_namespaceObject.join)((0, external_node_path_namespaceObject.dirname)(route.absolutePath), src);
                    if (!external_node_fs_default().existsSync(demoPath)) return;
                    const direction = (0, node_utils_namespaceObject.getNodeAttribute)(node, 'direction') || '';
                    const code = external_node_fs_default().readFileSync(demoPath, {
                        encoding: 'utf8'
                    });
                    const language = src.slice(src.lastIndexOf('.') + 1);
                    createPlaygroundNode(node, [
                        [
                            'code',
                            code
                        ],
                        [
                            'language',
                            language
                        ],
                        [
                            'direction',
                            direction
                        ],
                        [
                            'editorPosition',
                            editorPosition
                        ]
                    ]);
                }
            });
            (0, lib.Vn)(tree, 'code', (node)=>{
                if ('jsx' === node.lang || 'tsx' === node.lang) {
                    var _node_meta, _node_meta1;
                    const hasPureMeta = null == (_node_meta = node.meta) ? void 0 : _node_meta.includes('pure');
                    const hasPlaygroundMeta = null == (_node_meta1 = node.meta) ? void 0 : _node_meta1.includes('playground');
                    let noTransform;
                    switch(defaultRenderMode){
                        case 'pure':
                            noTransform = !hasPlaygroundMeta;
                            break;
                        case 'playground':
                            noTransform = hasPureMeta;
                            break;
                        default:
                            break;
                    }
                    if (noTransform) return;
                    const direction = getNodeMeta(node, 'direction') || '';
                    createPlaygroundNode(node, [
                        [
                            'code',
                            node.value
                        ],
                        [
                            'language',
                            node.lang
                        ],
                        [
                            'direction',
                            direction
                        ],
                        [
                            'editorPosition',
                            editorPosition
                        ]
                    ]);
                }
            });
        };
    };
    let cli_routeMeta;
    function pluginPlayground(options) {
        var _monacoLoader_paths;
        const { render = '', include, defaultDirection = 'horizontal', editorPosition = 'left', babelUrl = DEFAULT_BABEL_URL, monacoLoader = {}, monacoOptions = {}, defaultRenderMode = 'playground' } = options || {};
        const playgroundVirtualModule = new external_rspack_plugin_virtual_module_namespaceObject.RspackVirtualModulePlugin({});
        const getRouteMeta = ()=>cli_routeMeta;
        if (render && !/Playground\.(jsx?|tsx?)$/.test(render)) throw new Error('[Playground]: render should ends with Playground.(jsx?|tsx?)');
        const preloads = [];
        const monacoPrefix = ((null == (_monacoLoader_paths = monacoLoader.paths) ? void 0 : _monacoLoader_paths.vs) || DEFAULT_MONACO_URL).replace(/\/+$/, '');
        preloads.push(`${monacoPrefix}/loader.js`);
        preloads.push(`${monacoPrefix}/editor/editor.main.js`);
        return {
            name: '@rspress/plugin-playground',
            config (config, { removePlugin }) {
                config.markdown = config.markdown || {};
                config.markdown.mdxRs = false;
                removePlugin('@rspress/plugin-preview');
                return config;
            },
            async routeGenerated (routes) {
                cli_routeMeta = routes;
                const files = routes.map((route)=>route.absolutePath);
                const imports = {};
                await Promise.all(files.map(async (filepath, _index)=>{
                    const isMdxFile = /\.mdx?$/.test(filepath);
                    if (!isMdxFile) return;
                    const { createProcessor } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "@mdx-js/mdx"));
                    const { visit } = await __webpack_require__.e("301").then(__webpack_require__.bind(__webpack_require__, "../../node_modules/.pnpm/unist-util-visit@4.1.2/node_modules/unist-util-visit/index.js"));
                    const { default: remarkGFM } = await Promise.resolve().then(__webpack_require__.bind(__webpack_require__, "remark-gfm"));
                    try {
                        const processor = createProcessor({
                            format: external_node_path_default().extname(filepath).slice(1),
                            remarkPlugins: [
                                remarkGFM
                            ]
                        });
                        const source = await external_node_fs_default().promises.readFile(filepath, 'utf-8');
                        const ast = processor.parse(source);
                        visit(ast, 'mdxJsxFlowElement', (node)=>{
                            if ('code' === node.name) {
                                const src = (0, node_utils_namespaceObject.getNodeAttribute)(node, 'src');
                                if ('string' != typeof src) return;
                                const demoPath = (0, external_node_path_namespaceObject.join)(external_node_path_default().dirname(filepath), src);
                                if (!external_node_fs_default().existsSync(demoPath)) return;
                                const code = external_node_fs_default().readFileSync(demoPath, {
                                    encoding: 'utf8'
                                });
                                const thisImports = parseImports(code, external_node_path_default().extname(demoPath));
                                thisImports.forEach((x)=>{
                                    if (void 0 === imports[x]) imports[x] = x;
                                });
                            }
                        });
                        visit(ast, 'code', (node)=>{
                            if ('jsx' === node.lang || 'tsx' === node.lang) {
                                const { value, meta } = node;
                                const hasPureMeta = null == meta ? void 0 : meta.includes('pure');
                                const hasPlaygroundMeta = null == meta ? void 0 : meta.includes('playground');
                                let noTransform;
                                switch(defaultRenderMode){
                                    case 'pure':
                                        noTransform = !hasPlaygroundMeta;
                                        break;
                                    case 'playground':
                                        noTransform = hasPureMeta;
                                        break;
                                    default:
                                        break;
                                }
                                if (noTransform) return;
                                const thisImports = parseImports(value, node.lang);
                                thisImports.forEach((x)=>{
                                    if (void 0 === imports[x]) imports[x] = x;
                                });
                            }
                        });
                    } catch (e) {
                        console.error(e);
                        throw e;
                    }
                }));
                if (include) include.forEach((item)=>{
                    if ('string' == typeof item) imports[item] = item;
                    else imports[item[0]] = item[1];
                });
                if (!('react' in imports)) imports.react = 'react';
                const importKeys = Object.keys(imports);
                const code = [
                    ...importKeys.map((x, index)=>`import * as i_${index} from '${imports[x]}';`),
                    'const imports = new Map();',
                    ...importKeys.map((x, index)=>`imports.set('${x}', i_${index});`),
                    'function getImport(name, getDefault) {',
                    '  if (!imports.has(name)) {',
                    '    throw new Error("Module " + name + " not found");',
                    '  }',
                    '  const result = imports.get(name);',
                    '  if (getDefault && typeof result === "object") {',
                    '    return result.default || result;',
                    '  }',
                    '  return result;',
                    '}',
                    'export { imports };',
                    'export default getImport;'
                ].join('\n');
                playgroundVirtualModule.writeModule('_rspress_playground_imports', code);
            },
            builderConfig: {
                source: {
                    define: {
                        __PLAYGROUND_DIRECTION__: JSON.stringify(defaultDirection),
                        __PLAYGROUND_MONACO_LOADER__: JSON.stringify(monacoLoader),
                        __PLAYGROUND_MONACO_OPTIONS__: JSON.stringify(monacoOptions),
                        __PLAYGROUND_BABEL_URL__: JSON.stringify(babelUrl)
                    },
                    include: [
                        (0, external_node_path_namespaceObject.join)(__dirname, '..', '..', '..')
                    ]
                },
                html: {
                    tags: preloads.map((url)=>({
                            tag: 'link',
                            head: true,
                            attrs: {
                                rel: 'preload',
                                href: url,
                                as: "script"
                            }
                        }))
                },
                tools: {
                    rspack: {
                        plugins: [
                            playgroundVirtualModule
                        ]
                    }
                }
            },
            markdown: {
                remarkPlugins: [
                    [
                        remarkPlugin,
                        {
                            getRouteMeta,
                            editorPosition,
                            defaultRenderMode
                        }
                    ]
                ],
                globalComponents: [
                    render ? render : external_node_path_default().join(staticPath, 'global-components', 'Playground.tsx')
                ]
            },
            globalStyles: external_node_path_default().join(staticPath, 'global-styles', 'web.css')
        };
    }
})();
exports.pluginPlayground = __webpack_exports__.pluginPlayground;
exports.routeMeta = __webpack_exports__.routeMeta;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "pluginPlayground",
    "routeMeta"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
